###################################################
###################################################
##      import this library, not libepoch or     ##
##      whatever else                            ##
###################################################
###################################################

from pithy import *
from urllib import urlopen as uo
import json
#from libsiui import *
import libEpoch

class Acoustics():
    def __init__(self,muxurl=None,etherurl=None,pulser=None,pulserurl=None):
        self.pre = "/home/pi/acoustic/data/"
        
        self.muxurl = muxurl #check+add trailing /
        self.pulserurl = pulserurl
        #self.pulserurl = 'http://localhost:9002/EPOCHmux.csv' #cuz.
        #self.initurl = 'http://localhost:9002/EPOCHmux-init.csv'
        
        if pulser.lower()=="epoch":
            self.pulser="epoch"
            self.p = libepoch.epoch(pulserurl)
        elif pulser.lower()=="siui":
            self.pulser="siui"
            self.p = libsiui.SIUI(pulserurl)
            
    def switchmux(self,chan):
        try:
            uo(self.muxurl+"%i" % int(chan)).read()
        except:
            error = 'WARNING: No channel %s on this mux' % q['Channel']
            print error
            
    
    def getSingleData(self,queue,isTE=False):
        q=queue
        if isTE:
            label = "TR"
            func = ep.commanderTrans
        else:
            label = "PE"
            func = ep.commanderPE
        #print label
        try:
            fn = pre+"%s_%s_%s_%i.json" % 
                (q['Name'],q['Channel'],label,int(time.time()))
            data = func(gain=float(q[label+' Gain (dB)']),
                        tus_scale=int(q[label+' Time (us)']),
                        freq=float(q['Freq (MHz)']))
            rtime = [round(x,3) for x in list(data[0])]
            json.dump({'time (us)':rtime,'amp':list(data[1])}, open(fn,'w'))
        except:
            print '***ERROR***'
            import traceback
            print traceback.format_exc()


#mux map -> fixed to whatever it is for real
mm = {} 
mm[1] = 23
mm[2] = 25
mm[3] = 27
mm[4] = 29
mm[5] = 31
mm[6] = 33
mm[7] = 35
mm[8] = 37


init = False
while True:
    if init:
        queue = parsecsv(initurl)
        init = False
    else:
        queue = parsecsv(csvurl)
    for q in queue:
        #print q
        if q['Mode tr/pe/both'].lower() in ['tr','both']:
            switchmux(mm[int(q['Channel'])])
            getSingleData(q,True)
        if q['Mode tr/pe/both'].lower() in ['pe','both']:
            switchmux(mm[int(q['Channel'])]-1)
            getSingleData(q,False)
            




























